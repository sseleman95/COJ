void fft (P *a, int n,bool invert) {
   for (int i=1, j=0; i<n; ++i) {
      int bit = n >> 1;
      for (; j>=bit; bit>>=1)
         j -= bit;
      j += bit;
      if (i < j) swap (a[i], a[j]);
   }
   for (int len=2; len <= n; len <<= 1) {
      double ang = 2*PI/len * (invert ? -1 : 1);
      P wlen (cos(ang), sin(ang));
      for (int i=0; i<n; i += len) {
         P w (1,0);
         for (int j=0; j<len/2; ++j) {
            P u = a[i+j],  v = a[i+j+len/2] * w;
            a[i+j] = u + v;
            a[i+j+len/2] = u - v;
            w = w * wlen;
         }
      }
   }
   if (invert)
      for (int i=0; i<n; ++i)
         a[i].x /= n, a[i].y /= n;
}

int n1[MAXN], n2[MAXN], sol[MAXN], ln1,ln2,lsol,lfa,lfb;
P fa[MAXN], fb[MAXN];

void multiply () {
   int n = 1,i, x; lfa = lfb = 0;
   for(i=0;i<ln1;i++)
      fa[lfa++] = P(n1[i],0);
   for(i=0;i<ln2;i++)
      fb[lfb++] = P(n2[i],0);
   n=4<<(int)(log((double)max(ln1,ln2))/log(2.0));
   while(lfa < n || lfb < n){
      if (lfa < n) fa[lfa++] = P(0,0);
      if (lfb < n) fb[lfb++] = P(0,0);
   }
   lfa = lfb = n;
   fft (fa,n, false),  fft (fb,n, false);
   for (i=0; i<n; ++i)
      fa[i] = fa[i] * fb[i];
   fft (fa,n, true);
   for (x=i=0, lsol=-1; i<n; ++i){
      sol[i] = x + int (fa[i].x + 0.5);
      x = sol[i] / 10;
      sol[i] %= 10;
      if (sol[i]) lsol = i;
   }
}

