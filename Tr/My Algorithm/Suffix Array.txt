#include <algorithm>
#include <numeric>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <stack>
#include <cstdio>
#include <cstdlib>
#include <cctype>
#include <cassert>
#include <cmath>
#include <complex>
#include <memory.h>
#include <time.h>
#include <list>

using namespace std;
#define MAXN 100010

int we[MAXN], P[MAXN], wv[MAXN], wa[MAXN], wb[MAXN];
int Num[MAXN], Rank[MAXN], lcp[MAXN];

inline int cmp(int *r, int a, int b, int l) {
	return r[a] == r[b] && r[a + l] == r[b + l];
}

//Suffix Array O(n log(n))
void SA(int N, int range) {
	int i, j, p, *x = wa, *y = wb;
	memset(we, 0, range * sizeof(int));
	for (int i = 0; i < N; i++)
		we[x[i] = Num[i]]++;
	for (int i = 1; i < range; i++)
		we[i] += we[i - 1];
	for (int i = N - 1; i >= 0; i--)
		P[--we[x[i]]] = i;
	for (j = 1, p = 0; p < N; j *= 2, range = p) {
		for (p = 0, i = N - j; i < N; i++)
			y[p++] = i;
		for (i = 0; i < N; i++)
			if (P[i] >= j)
				y[p++] = P[i] - j;
		for (i = 0; i < N; i++)
			wv[i] = x[y[i]];
		memset(we, 0, range * sizeof(int));
		for (i = 0; i < N; i++)
			we[wv[i]]++;
		for (i = 1; i < range; i++)
			we[i] += we[i - 1];
		for (i = N - 1; i >= 0; i--)
			P[--we[wv[i]]] = y[i];
		swap(x, y);
		x[P[0]] = 0;
		for (p = i = 1; i < N; i++)
			x[P[i]] = cmp(y, P[i], P[i - 1], j) ? p - 1 : p++;
	}
}

// inner LCP computation with memoise: Amortized O(1), init mem[0..n] := -1
int getLCP(int i, int j, int *lcp, int *mem) {
	if (i + 1 == j)
		return lcp[j];
	if (mem[(i + j) / 2] < 0)
		mem[(i + j) / 2] = min(getLCP(i, (i + j) / 2, lcp, mem),
				getLCP((i + j) / 2, j, lcp, mem));
	return mem[(i + j) / 2];
}

int computeLCP(char *t, int n, char *p, int m, int o, int k) {
	int i = o;
	for (; i < m && k + i < n && p[i] == t[k + i]; ++i)
		;
	return i;
}

#define COMP(h, k) (h == m || (k + h < n && p[h] < t[k + h]))

//String Matching O(m + log(n))
int find(char *t, int n, char *p, int m) {
	int mem[n + 1];
	fill(mem, mem + n + 1, -1);
	int l = 0, lh = 0, r = n, rh = computeLCP(t, n + 1, p, m, 0, P[n]);
	if (!COMP(rh, P[r]))
		return -1;
	for (int k = (l + r) / 2; l + 1 < r; k = (l + r) / 2) {
		int A = getLCP(l, k, lcp, mem), B = getLCP(k, r, lcp, mem);
		if (A >= B) {
			if (lh < A)
				l = k;
			else if (lh > A)
				r = k, rh = A;
			else {
				int i = computeLCP(t, n + 1, p, m, A, P[k]);
				if (COMP(i, P[k]))
					r = k, rh = i;
				else
					l = k, lh = i;
			}
		} else {
			if (rh < B)
				r = k;
			else if (rh > B)
				l = k, lh = B;
			else {
				int i = computeLCP(t, n + 1, p, m, B, P[k]);
				if (COMP(i, P[k]))
					r = k, rh = i;
				else
					l = k, lh = i;
			}
		}
	}
	return rh == m ? r : -1;
}

void find_lcp(int n) {
	for (int i = 1; i <= n; i++)
		Rank[P[i]] = i;
	int k = 0, j;
	for (int i = 0; i < n; lcp[Rank[i++]] = k)
		for (k ? k-- : 0, j = P[Rank[i] - 1]; Num[i + k] == Num[j + k]; k++)
			;
}

char s[MAXN];
int main() {
	scanf("%s", s);
	int n = strlen(s);
	for (int i = 0; i < n; i++)
		Num[i] = s[i];
	Num[n] = 0;
	SA(n + 1, 130);
	find_lcp(n);
	//print suffix array
	for (int i = 1; i <= n; i++) {
		cout << lcp[i] << " ";
		for (int j = P[i]; j < n; ++j) {
			cout << s[j];
		}
		cout << endl;
	}
}
