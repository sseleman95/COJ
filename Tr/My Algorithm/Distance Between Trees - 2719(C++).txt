#include <algorithm>
#include <numeric>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <stack>
#include <cstdio>
#include <cstdlib>
#include <cctype>
#include <cassert>
#include <cmath>
#include <complex>
#include <memory.h>
#include <time.h>
#include <list>

using namespace std;
typedef complex<double> P;
#define curr(P, i) P[i]
#define next(P, i) P[(i+1)%P.size()]
#define diff(P, i) (next(P, i) - curr(P, i))

double cross(P p1, P p2) {
	return p1.real() * p2.imag() - p1.imag() * p2.real();
}

double convex_diameter(const vector<P> &pt, int N) {
	const int n = N;
	int is = 0, js = 0;
	for (int i = 1; i < n; ++i) {
		if (imag(pt[i]) > imag(pt[is]))
			is = i;
		if (imag(pt[i]) < imag(pt[js]))
			js = i;
	}
	double maxd = norm(pt[is] - pt[js]);
	int i, maxi, j, maxj;
	i = maxi = is;
	j = maxj = js;
	do {
		if (cross(diff(pt,i), diff(pt,j)) >= 0)
			j = (j + 1) % n;
		else
			i = (i + 1) % n;
		if (norm(pt[i] - pt[j]) > maxd) {
			maxd = norm(pt[i] - pt[j]);
			maxi = i;
			maxj = j;
		}
	} while (i != is || j != js);
	return hypot(pt[maxi].real() - pt[maxj].real(), pt[maxi].imag() - pt[maxj].imag());
}

inline bool cmp(const P& p1, const P &p2) {
	if(p1.real() != p2.real())
		return p1.real() < p2.real();
	return p1.imag() < p2.imag();
}

P ps[100005];
vector<P> vertex(200005);

int main() {
	//freopen("f", "r", stdin);
	int n, m;
	scanf("%d%d", &n, &m);
	n += m;
	for (int i = 0; i < n; ++i)
		scanf("%lf%lf", &ps[i].real(), &ps[i].imag());
	sort(ps, ps + n, cmp);
	int cnt = 1;
	for (int i = 1; i < n; ++i) {
		if (ps[i] != ps[i - 1])
			cnt++;
	}
	if (cnt == 1)
		printf("0.0000\n");
	else {
		int k = 0;
		for (int i = 0; i < n; vertex[k++] = ps[i++])
			while (k >= 2 && cross(vertex[k - 1] - vertex[k - 2], ps[i] - vertex[k - 2]) <= 0)
				--k;
		for (int i = n - 2, t = k + 1; i >= 0; vertex[k++] = ps[i--])
			while (k >= t && cross(vertex[k - 1] - vertex[k - 2], ps[i] - vertex[k - 2]) <= 0)
				--k;
		k--;
		double sol = convex_diameter(vertex, k);
		printf("%.4lf\n", sol);
	}
}
