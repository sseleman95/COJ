#define SIZE(t) ((int)((t).size()))
#define MAXN 100
#define MAXLOG 17

int N;
vector<vector<int> > G;
vector<vector<int> > children;
vector<int> parent;
vector<int> time_in, time_out;
vector<vector<int> > paths;
vector<int> path_id, path_offset;
vector<vector<p2i> > trees;
int L[MAXN], P[MAXN][MAXLOG];

void dfs() {
	parent.clear();
	parent.resize(N);
	children.clear();
	children.resize(N);
	time_in.clear();
	time_in.resize(N);
	time_out.clear();
	time_out.resize(N);
	paths.clear();
	vector<bool> visited(N, false);
	vector<int> walk;
	vector<int> subtree_size(N, 0);
	int time = 0;
	stack<int> vertex, edge;
	visited[0] = true;
	time_in[0] = time;
	parent[0] = 0;
	vertex.push(0);
	edge.push(0);
	while (!vertex.empty()) {
		++time;
		int kde = vertex.top();
		vertex.pop();
		int e = edge.top();
		edge.pop();
		if (e == SIZE(G[kde])) {
			walk.push_back(kde);
			time_out[kde] = time;
			subtree_size[kde] = 1;
			for (int i = 0; i < SIZE(children[kde]); ++i)
				subtree_size[kde] += subtree_size[children[kde][i]];
		} else {
			vertex.push(kde);
			edge.push(e + 1);
			int kam = G[kde][e];
			if (!visited[kam]) {
				visited[kam] = true;
				time_in[kam] = time;
				parent[kam] = kde;
				L[kam] = L[kde] + 1;
				children[kde].push_back(kam);
				vertex.push(kam);
				edge.push(0);
			}
		}
	}
	vector<bool> parent_edge_processed(N, false);
	parent_edge_processed[0] = true;
	for (int i = 0; i < SIZE(walk); ++i) {
		int w = walk[i];
		if (parent_edge_processed[w])
			continue;
		vector<int> this_path;
		this_path.push_back(w);
		while (1) {
			bool is_parent_edge_heavy = (2 * subtree_size[w]
					>= subtree_size[parent[w]]);
			parent_edge_processed[w] = true;
			w = parent[w];
			this_path.push_back(w);
			if (!is_parent_edge_heavy)
				break;
			if (parent_edge_processed[w])
				break;
		}
		paths.push_back(this_path);
	}
	vector<int> l;
	l.push_back(0);
	paths.push_back(l);
	path_id.clear();
	path_id.resize(N);
	path_id[0] = -1;
	path_offset.clear();
	path_offset.resize(N);
	for (int i = 0; i < SIZE(paths); ++i)
		for (int j = 0; j < SIZE(paths[i]) - 1; ++j) {
			path_id[paths[i][j]] = i;
			path_offset[paths[i][j]] = j;
		}
}