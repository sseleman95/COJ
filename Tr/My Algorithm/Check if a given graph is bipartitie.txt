//el algoritmo sirve ademas para encontrar en que conjuntos estan los nodo
//ademas de saber si es posible o no crear un grafo bipartito, o si existe mas de 2 grupos posibles

#include <algorithm>
#include <numeric>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <stack>
#include <cstdio>
#include <cstdlib>
#include <cctype>
#include <cassert>
#include <cmath>
#include <complex>
#include <memory.h>
#include <time.h>
#include <list>

using namespace std;
#define MAXN 10001

vector<int> g[MAXN];
int part[MAXN];
bool possible, multiples;
int p;

void check(int nod) {
	if (!possible)
		return;
	if (part[nod] == -1) {
		if (p > 1)
			multiples = true;
		part[nod] = p;
		p += 2;
	}
	for (int i = 0; i < (int) g[nod].size(); ++i) {
		int v = g[nod][i];
                if(v == nod)
                   continue;
		if (part[v] == -1) {
			part[v] = (part[nod] % 2) ? part[nod] - 1 : part[nod] + 1;
			check(v);
		} else if (part[v] == part[nod]) {
			possible = false;
			break;
		}
	}
}

int main() {
	int N, M;
	while (scanf("%d%d", &N, &M) != EOF) {
		if (N <= 1) {
			while (M-- > 0) {
				int a, b;
				scanf("%d%d", &a, &b);
			}
			printf("no\n");
		} else {
			memset(part, -1, sizeof part);
			possible = true;
			multiples = false;
			p = 0;
			for (int i = 1; i <= N; ++i)
				g[i].clear();
			while (M--) {
				int a, b;
				scanf("%d%d", &a, &b);
				g[a].push_back(b);
				g[b].push_back(a);
			}
			for (int i = 1; i <= N; ++i)
				check(i);
			if (!possible)
				printf("no group\n");
			else if (possible) {
				if (multiples)
					printf("multiple group\n");
				else {
					printf("Group 1:");
					for (int i = 1; i <= N; ++i)
						if (!part[i])
							printf(" %d", i);
					printf("\nGroup 2:");
					for (int i = 1; i <= N; ++i)
						if (part[i])
							printf(" %d", i);
					printf("\n");
				}
			}
		}
		printf("\n");
	}
        return 0;
}