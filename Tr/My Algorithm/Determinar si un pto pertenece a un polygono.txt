//los ptos tienen que estar ordenados clockwise o counterclockwise
//manejar el caso de que el pto este en la misma arista del polygono
//en caso de que halla que incluirlo
#define EPS 1e-9

struct point {
	int x, y;
};

double polarAngle(point p) {
	if (fabs(p.x) <= EPS && fabs(p.y) <= EPS)
		return -1.0;
	if (fabs(p.x) <= EPS)
		return (p.y > EPS ? 1.0 : 3.0) * acos(0);
	double theta = atan(1.0 * p.y / p.x);
	if (p.x > EPS)
		return (p.y >= -EPS ? theta : (4 * acos(0) + theta));
	return (2 * acos(0) + theta);
}

bool pointInPoly(point p, point poly[], int n) {
	double ang = 0.0;
	for (int i = n - 1, j = 0; j < n; i = j++) {
		point v = (point) {poly[i].x - p.x, poly[i].y - p.y};
		point w = (point) {poly[j].x - p.x, poly[j].y - p.y};
		double va = polarAngle(v);
		double wa = polarAngle(w);
		double xx = wa - va;
		if (va < -0.5 || wa < -0.5 || fabs(fabs(xx) - 2 * acos(0)) < EPS) {
		    //ON THE EDGE
			ang += 2 * acos(0);
			continue;
		}
		if (xx < -2 * acos(0))
			ang += xx + 4 * acos(0);
		else if (xx > 2 * acos(0))
			ang += xx - 4 * acos(0);
		else
			ang += xx;
	}
	return (ang * ang > 1.0);
}